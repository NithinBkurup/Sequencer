<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Resequencing - MPAS</title>
  <link rel="stylesheet" href="resequencing.css">
  </head>
<body>
  <div class="main-container">
    <div class="header">
      <h1>üîÑ Resequencing</h1>
      <div class="info" id="headerInfo">Loading...</div>
      <button class="btn-refresh" onclick="window.refreshData()" id="refreshBtn" title="Refresh data from database">
        üîÑ Refresh
      </button>
    </div>

    <div class="container">
      <div class="panel">
        <div class="panel-header">
          <span>Scheduled Orders - Drag ‚áÖ to Reorder</span>
          <span class="count" id="leftCount">0</span>
        </div>
        <div class="panel-body">
          <table>
            <thead>
              <tr>
                <th style="width: 25px;">‚áÖ</th>
                <th>Material Code</th>
                <th>Material Description</th>
                <th>Serial No</th>
                <th>Order No</th>
                <th>Scheduled Time</th>
              </tr>
            </thead>
            <tbody id="leftBody">
              <tr><td colspan="6" class="empty-state">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <span>Material Groups - Drag ‚áÖ to Reorder Blocks</span>
          <span class="count" id="rightCount">0</span>
        </div>
        <div class="panel-body">
          <table>
            <thead>
              <tr>
                <th style="width: 25px;">‚áÖ</th>
                <th>Material Code</th>
                <th>Material Description</th>
                <th style="width: 80px;">Count</th>
                <th>First Scheduled</th>
              </tr>
            </thead>
            <tbody id="rightBody">
              <tr><td colspan="5" class="empty-state">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="actions">
      <div class="success-message" id="successMessage">‚úì Resequence committed successfully!</div>
      <button class="btn btn-ok" onclick="window.okResequence()" id="commitBtn">‚úì OK - Commit</button>
    </div>
  </div>

  <script type="module">
    import { getParams } from "./app.js";
    import { loadOrders, commitResequence } from "./api.js";
    import { state, buildMaterialGroups } from "./state.js";

    const p = getParams();

    try {
      const rows = await loadOrders({ ...p, mode: "Resequence" });

      console.log("Loaded resequence orders:", rows);

      document.getElementById('headerInfo').textContent =
        `PlantCode: ${p.plant} | LineCode: ${p.line} | ${p.from} to ${p.to} | MaterialCode: ${p.material || 'ALL'}  | Total: ${rows.length} | User: ${p.username || 'N/A'} | Client: ${p.clientid || 'N/A'}`;

      state.right = rows
        .filter(o => o.Sflag === 2 && o.OrderStatus === 'Ready' && o.ScheduledTime)
        .map(o => ({ ...o, RowID: parseInt(o.RowID) }))
        .sort((a,b) => new Date(a.ScheduledTime) - new Date(b.ScheduledTime));

      console.log("Filtered ready orders:", state.right.length);

      buildMaterialGroups();

      let draggedItem = null;
      let draggedFrom = null;

      function renderRows() {
        const tbody = document.getElementById('leftBody');
        document.getElementById('leftCount').textContent = state.right.length;

        if (state.right.length === 0) {
          tbody.innerHTML = '<tr><td colspan="6" class="empty-state">No orders ready for resequencing</td></tr>';
          return;
        }

        tbody.innerHTML = state.right.map(o => {
          return `
            <tr data-rowid="${o.RowID}" draggable="true">
              <td class="drag-handle">‚áÖ</td>
              <td>${o.MaterialCode}</td>
              <td>${o.MaterialDesc || 'N/A'}</td>
              <td>${o.SerialNo}</td>
              <td>${o.OrderNo}</td>
              <td><span class="time-badge">${new Date(o.ScheduledTime).toLocaleString('en-GB', {hour: '2-digit', minute: '2-digit', hour12: false})}</span></td>
            </tr>
          `;
        }).join('');

        attachRowHandlers();
      }

      function renderMaterials() {
        const tbody = document.getElementById('rightBody');
        document.getElementById('rightCount').textContent = state.materialGroups.length;

        if (state.materialGroups.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" class="empty-state">No material groups</td></tr>';
          return;
        }

        tbody.innerHTML = state.materialGroups.map((m, index) => {
          return `
            <tr data-group-index="${index}" draggable="true" data-material-group="true">
              <td class="drag-handle">‚áÖ</td>
              <td>${m.MaterialCode}</td>
              <td>${m.MaterialDesc || 'N/A'}</td>
              <td>${m.Count} orders</td>
              <td><span class="time-badge">${new Date(m.ScheduledTime).toLocaleString('en-GB', {hour: '2-digit', minute: '2-digit', hour12: false})}</span></td>
            </tr>
          `;
        }).join('');

        attachMaterialHandlers();
      }

      function attachRowHandlers() {
        const tbody = document.getElementById('leftBody');

        tbody.querySelectorAll('tr[data-rowid]').forEach(row => {
          const rowId = parseInt(row.dataset.rowid);

          row.addEventListener('dragstart', () => {
            draggedItem = state.right.find(r => r.RowID === rowId);
            draggedFrom = 'row';
            row.classList.add('dragging');
          });

          row.addEventListener('dragend', () => {
            row.classList.remove('dragging');
          });

          row.addEventListener('dragover', (e) => {
            if (draggedFrom === 'row') {
              e.preventDefault();

              const dragging = tbody.querySelector('.dragging');
              if (!dragging || dragging === row) return;

              const bounding = row.getBoundingClientRect();
              const offset = e.clientY - bounding.top;

              if (offset > bounding.height / 2) {
                row.parentNode.insertBefore(dragging, row.nextSibling);
              } else {
                row.parentNode.insertBefore(dragging, row);
              }
            }
          });

          row.addEventListener('drop', (e) => {
            if (draggedFrom === 'row') {
              e.preventDefault();

              // Get current order of rows in DOM
              const rows = Array.from(tbody.querySelectorAll('tr[data-rowid]'));
              const rowIds = rows.map(r => parseInt(r.dataset.rowid));

              // Create new ordered array
              const newOrder = rowIds.map(id => state.right.find(o => o.RowID === id)).filter(Boolean);

              // Extract all scheduled times (sorted)
              const times = [...state.right].sort((a,b) => new Date(a.ScheduledTime) - new Date(b.ScheduledTime))
                                           .map(o => o.ScheduledTime);

              // Assign times to new order
              newOrder.forEach((order, index) => {
                order.ScheduledTime = times[index];
              });

              // Update state
              state.right = newOrder;
              buildMaterialGroups();

              draggedItem = null;
              draggedFrom = null;

              renderRows();
              renderMaterials();

              console.log('Row reordered - times swapped');
            }
          });
        });
      }

      function attachMaterialHandlers() {
        const tbody = document.getElementById('rightBody');

        tbody.querySelectorAll('tr[data-group-index]').forEach(row => {
          const groupIndex = parseInt(row.dataset.groupIndex);

          row.addEventListener('dragstart', () => {
            draggedItem = state.materialGroups[groupIndex];
            draggedFrom = 'material';
            row.classList.add('dragging');
          });

          row.addEventListener('dragend', () => {
            row.classList.remove('dragging');
          });

          row.addEventListener('dragover', (e) => {
            if (draggedFrom === 'material') {
              e.preventDefault();

              const dragging = tbody.querySelector('.dragging');
              if (!dragging || dragging === row) return;

              const bounding = row.getBoundingClientRect();
              const offset = e.clientY - bounding.top;

              if (offset > bounding.height / 2) {
                row.parentNode.insertBefore(dragging, row.nextSibling);
              } else {
                row.parentNode.insertBefore(dragging, row);
              }
            }
          });

          row.addEventListener('drop', (e) => {
            if (draggedFrom === 'material') {
              e.preventDefault();

              // Get current order of material groups in DOM
              const rows = Array.from(tbody.querySelectorAll('tr[data-group-index]'));
              const groupIndices = rows.map(r => parseInt(r.dataset.groupIndex));

              // Create new ordered material groups based on the DOM order
              const newMaterialOrder = groupIndices.map(idx => state.materialGroups[idx]);

              // Extract all scheduled times (sorted) and get the earliest time
              const validTimes = state.right
                .map(o => new Date(o.ScheduledTime))
                .filter(d => !isNaN(d.getTime()))
                .sort((a,b) => a - b);

              if (validTimes.length === 0) {
                console.error("No valid scheduled times found");
                return;
              }

              // Start from the earliest scheduled time
              let currentTime = new Date(validTimes[0]);
              // Zero out milliseconds for clean timestamps
              currentTime.setMilliseconds(0);
              
              const taktMs = 240 * 1000; // 4 minutes in milliseconds

              const newRightOrder = [];

              // Assign new sequential times to reordered material groups
              newMaterialOrder.forEach(group => {
                group.Orders.forEach(order => {
                  // Create clean date object with milliseconds zeroed
                  const scheduledTime = new Date(currentTime);
                  scheduledTime.setMilliseconds(0);
                  order.ScheduledTime = scheduledTime;
                  
                  newRightOrder.push(order);
                  
                  // Increment time for next order
                  currentTime = new Date(currentTime.getTime() + taktMs);
                });
              });

              // Update state
              state.right = newRightOrder;
              buildMaterialGroups();

              draggedItem = null;
              draggedFrom = null;

              renderRows();
              renderMaterials();

              console.log('Material group reordered - sequential times assigned');
            }
          });
        });
      }

      window.okResequence = async () => {
        if (state.right.length === 0) {
          alert('No orders to resequence!');
          return;
        }

        const commitBtn = document.getElementById('commitBtn');
        const successMsg = document.getElementById('successMessage');

        commitBtn.disabled = true;
        commitBtn.textContent = '‚è≥ Committing...';

        try {
          await commitResequence(state.right, p.username, p.clientid);

          successMsg.classList.add('show');
          commitBtn.textContent = '‚úì Committed';

          setTimeout(() => {
            window.location.reload();
          }, 2000);
        } catch (e) {
          commitBtn.disabled = false;
          commitBtn.textContent = '‚úì OK - Commit';
          alert('‚ùå Error: ' + e.message);
        }
      };

      window.refreshData = async () => {
        const refreshBtn = document.getElementById('refreshBtn');
        refreshBtn.disabled = true;
        refreshBtn.classList.add('refreshing');
        refreshBtn.textContent = 'üîÑ Refreshing...';

        try {
          // Reload orders from database
          const rows = await loadOrders({ ...p, mode: "Resequence" });

          // Update state
          state.right = rows
            .filter(o => o.Sflag === 2 && o.OrderStatus === 'Ready' && o.ScheduledTime)
            .map(o => ({ ...o, RowID: parseInt(o.RowID) }))
            .sort((a,b) => new Date(a.ScheduledTime) - new Date(b.ScheduledTime));

          // Update header info
          document.getElementById('headerInfo').textContent =
            `PlantCode: ${p.plant} | LineCode: ${p.line} | ${p.from} to ${p.to} | MaterialCode: ${p.material || 'ALL'} | Total: ${rows.length} | User: ${p.username || 'N/A'} | Client: ${p.clientid || 'N/A'}`;

          // Rebuild material groups
          buildMaterialGroups();

          // Re-render
          renderRows();
          renderMaterials();

          console.log('Data refreshed successfully');
        } catch (error) {
          console.error('Error refreshing data:', error);
          alert('‚ùå Failed to refresh data: ' + error.message);
        } finally {
          refreshBtn.disabled = false;
          refreshBtn.classList.remove('refreshing');
          refreshBtn.textContent = 'üîÑ Refresh';
        }
      };

      renderRows();
      renderMaterials();

    } catch (error) {
      console.error('Error:', error);
      document.getElementById('leftBody').innerHTML =
        `<tr><td colspan="6" class="empty-state" style="color: #f44336;">Error: ${error.message}</td></tr>`;
    }
  </script>
</body>
</html>